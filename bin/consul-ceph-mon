#!/usr/bin/env perl

use strict;

use Log::Log4perl qw(:easy);
Log::Log4perl->easy_init($INFO);

use URI;
use JSON qw(decode_json encode_json);
use MIME::Base64 qw(decode_base64);
use Sys::Hostname qw(hostname);
use Socket;
use Data::Dumper;

my $ceph_timeout = 15;

use LWP::UserAgent::Determined;
my $ua =  LWP::UserAgent::Determined->new();
$ua->timeout(300);

my $consul = "http://localhost:8500";

my $path = shift @ARGV;

my $url = URI->new($path);
if (not $url->scheme) {
  $url = URI->new("$consul/v1/kv$path");
}

# XXX: Should look at /v1/session/node/$node_id and possibly re-use/renew our session
my $session = $ua->put("$consul/v1/session/create", Content => encode_json({ Name => "ceph-mon", Behavior => "delete" }));
my $session_decoded = decode_json($session->content);
my $session_id = $session_decoded->{ID};

my $hostname = hostname;
my($addr)=inet_ntoa((gethostbyname(hostname))[4]);

my $instance_check = $ua->get("http://169.254.169.254/latest/meta-data/instance-id");
if ($instance_check->is_success) {
  $hostname = $instance_check->content;
}

# Create the pseudo-folder *without* a session if it doesn't already exists
$ua->put("$consul/v1/kv$path/?cas=0");

my $node_path = "$consul/v1/kv$path/$hostname";

my $register = $ua->put("$node_path?acquire=$session_id", Content => encode_json({ name => $hostname, address => $addr }) );

if (!$register->is_success()) {
  WARN "Couldn't register node at $node_path";
  WARN Dumper($register);
  exit;
}

my $run = 1;
my $last_index = 0;
while($run) {
  my $list = $ua->get("$consul/v1/kv$path?recurse=1&index=$last_index");
  
  if (!$list->is_success()) {
    if ($list->status_line !~ /timeout/i ) {
      WARN "Retrieving node list failed from $consul/v1/kv$path?recurse=1&index=$last_index";
      WARN Dumper($list); use Data::Dumper;
    }
    next;
  }
  
  my $data = eval { decode_json($list->content); };
  if ($@ || not defined $data) {
    WARN "Failed decoding JSON: $@";
    next;
  }

  $last_index = $list->header("X-Consul-Index");
  
  my %mons;
  my $mon_dump = `ceph --connect-timeout $ceph_timeout -f json mon dump`;

  if (0 != $?) {
    WARN "Failed executing ceph mon dump: $? $!";
    next;
  }

  my $mons = eval { decode_json($mon_dump); };
  if ($@ or not defined $mons) {
    WARN "Failed decoding JSON: $@";
    next;
  }
  
  foreach my $mon (@{$mons->{mons}}) {
    # don't include ourselves
    next if $mon->{name} eq $hostname;
    $mons{$mon->{name}} = 1;
  }
  
  INFO "Locally known mons are : " . join(",", sort keys %mons);
  
  foreach my $node (sort { $a->{'ModifyIndex'} <=> $b->{'ModifyIndex'} } @$data) {
    # Skip the mon/ node itself, it's just a placeholder
    next if not defined $node->{Value};

    #XXX: Need to handle bogus data here
    my $value = eval { decode_base64($node->{Value}) };
    my $decoded = eval { decode_json($value) };

    if (not defined $value or not defined $decoded) {
        WARN "Found invalid node value for $node";
        next;
    }
    
    my $name = $decoded->{name};
    my $addr = $decoded->{address};
    
    # don't include ourselves, like, ever
    next if $name eq $hostname;
    
    if (exists $mons{$name}) {
      INFO "Already known mon $name";
    }
    else {
      WARN "ADD $name $addr\n";
      system("ceph --connect-timeout $ceph_timeout mon add $decoded->{name} $decoded->{address}");
    }
    
    delete $mons{$name};
  }
  
  foreach my $node (sort keys %mons) {
    INFO "DEL $node\n";
    system("ceph --connect-timeout $ceph_timeout mon remove $node");
  }
}
